ここでの目標は、ブロックチェーンにコードを保存することです。EVMは、クライアント（geth, parity）にどの部分の**Call Data**を保存するかを伝える必要があります。このステップでは、コントラクタを除いた（これは一度だけ実装されるため）契約と、保存する必要のない入力パラメータを保存します。

`CODECOPY`は最初のステップです：バイトコードをメモリにコピーし、その後イーサリアムクライアントがそれを消費できるようにします。MUNCH！

しかし待ってください...クライアントがバイトコードを**MUNCH**する前に、それをMUNCHするように指示する命令が必要です。`RETURN`がこのオペコードです！

一般的な仕様に記載されているように、契約作成の最後に、クライアント（geth, parity）は`RETURN`オペコードによってターゲットとされた値を取得し、それをデプロイされたバイトコードの一部として**永続化**します。

`CODECOPY`に到達したら、**Stack**の上位3つのアイテムを見てください：
`0: 0x0000000000000000000000000000000000000000000000000000000000000000`
`1: 0x0000000000000000000000000000000000000000000000000000000000000055`
`2: 0x000000000000000000000000000000000000000000000000000000000000003e`

*スタック内の`1`と`2`は少し異なる場合があります。これはコンパイラのバージョンの違いによるものかもしれません。*

**これらは`CODECOPY`のパラメータです。**

覚えておいてください: *codecopy(t, f, s)* - コードの位置**f**からメモリの位置**t**に**s**バイトをコピーします。

`0`はコピーされたコードが**メモリ**内のどこに配置されるかのオフセットです。この例では（全てゼロ）、コードはメモリの先頭にコピーされます。（**t**）
`1`は**calldata**内でどこからコピーするかのオフセットです。（**f**）
`2`はコピーするバイト数です。（**s**）


`CODECOPY`が実行された後、（*step into*ボタンをクリック）、コピーされたコードはメモリに次のように格納されます：
`0x6080604052600080fdfea265627a7a7231582029bb0975555a15a155e2cf28e025c8d492f0613bfb5cbf96399f6dbd4ea6fc9164736f6c63430005110032`。

**これを(X)と呼びます。**


デバッガの**Memory**パネルを見てみましょう。
上記の0x番号は、**Memory**パネルで表示されるものとは異なります。実際に表示されるのは次のようなものです：
0x0: 6080604052600080fdfea265627a7a72 ????R??????ebzzr
0x10: 31582029bb0975555a15a155e2cf28e0 1X ?? uUZ??U????
0x20: 25c8d492f0613bfb5cbf96399f6dbd4e ?????a?????9?m?N
0x30: a6fc9164736f6c634300051100320000 ???dsolcC????2??
0x40: 00000000000000000000000000000000 ????????????????
0x50: 000000000000000000000000000000a0 ??????????????? 
0x60: 00000000000000000000000000000000 ????????????????
0x70: 00000000000000000000000000000000 ????????????????
0x80: 00000000000000000000000000000000 ????????????????
0x90: 00000000000000000000000000000002 ????????????????


`0x0`、`0x10`などは位置を示しています。その次の数字はその位置のバイトコードです。これは続いて疑問符やランダムな文字や数字が表示されます。これは**Remix**がこれを文字列に変換しようとする試みです。

ですので、最初の4つのセクションのバイトコードを結合すると、次のようになります：
**0x6080604052600080fdfea265627a7a7231582029bb0975555a15a155e2cf28e025c8d492f0613bfb5cbf96399f6dbd4ea6fc9164736f6c63430005110032**。

最後のセクション - `0x90`には、コンストラクタのパラメータとして入力した2が含まれています。

**Call Data**パネルからの入力データは次のとおりです：
`0x6080604052348015600f57600080fd5b506040516093380380609383398181016040526020811015602f57600080fd5b81019080805190602001909291905050508060008190555050603e8060556000396000f3fe6080604052600080fdfea265627a7a7231582029bb0975555a15a155e2cf28e025c8d492f0613bfb5cbf96399f6dbd4ea6fc9164736f6c634300051100320000000000000000000000000000000000000000000000000000000000000002`

**この値を(Y)と呼びます。**

これは、`(X)`が元のcalldata `(Y)`のサブセットであることを示しています：

`(X)`は入力パラメータ `0000000000000000000000000000000000000000000000000000000000000002` を含まないcalldataです（これを保存する必要はありません）
また、1回だけ実行されるべきコンストラクタコード `6080604052348015600f57600080fd5b506040516093380380609383398181016040526020811015602f57600080fd5b81019080805190602001909291905050508060008190555050603e8060556000396000f3fe` を含みません。

つまり、`CODECOPY`はcalldataからバイトコードを抽出し、それをメモリにコピーします。

次のステップに進みましょう。
