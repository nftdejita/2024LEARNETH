このセクションでは、オークションを開始するための関数とNFTに入札するための関数を作成します。

### Start
必要な条件が満たされているかどうかを確認するために、いくつかの制御構造を使用して、販売者がオークションを開始できるようにします。

まず、オークションがすでに開始されているかどうかを確認します（49行目）。開始されている場合、状態変数`started`は`true`を返し、関数を終了して例外をスローします。

次に、関数を実行しているのが販売者であるかどうかを確認します（50行目）。販売者のアドレスを`seller`状態変数に保存する関数はすでに作成されているので、スタート関数を実行しているアカウントが販売者であるかどうかを確認できます。違う場合は例外をスローします。

次に、オークションに出品されるNFTを販売者からコントラクトに転送します（52行目）。
状態変数`started`を`true`に設定し（53行目）、オークションの終了日を作成します（54行目）。この場合、スタート関数が呼び出されてから7日後となります。リテラル数字の後に`days`のような接尾辞を使用して時間の単位を指定できます。時間単位について詳しく知りたい場合は、<a href="https://docs.soliditylang.org/en/latest/units-and-global-variables.html#time-units" target="_blank">Solidityドキュメント</a>を参照してください。

最後に、`Start()`イベントを発生させます（56行目）。

### Bid
関数呼び出し者が入札できる前に、特定の条件が満たされていることを確認する必要があります。オークションが開始されていること（60行目）、オークションが終了していないこと（61行目）、入札（呼び出しに付随する値）が現在の最高入札額を上回っていること（62行目）が条件です。

次に、新しい入札を行う前に現在の最高入札者の入札を保存します。
まず、入札者がいるかどうかを確認します（64行目）。この関数呼び出しが最初の入札である場合、次の行は無関係です。
マッピング`bids`（34行目）では、入札者のアドレスをキーに、入札者が引き出す前にオークションで入札したETHの総額を表す`uint`値にマップします。
入札者がいる場合、引き出す前に`highestBidder`の最後の入札（`highestBid`）をその総価値に追加します（65行目）。
入札者がもはや最高入札者でない場合、入札に使用したETHを引き出せるようにするために入札を保存します。

次に、関数を呼び出すアカウントを`highestBidder`に設定し（68行目）、その入札額（呼び出しに付随する値）を`highestBid`に設定します（69行目）。

最後に、`Bid`イベントを発生させます（71行目）。

## ⭐️ 課題
1. NFTコントラクトをデプロイします。「Solidity NFT Course」Learnethコースで作成したNFTコントラクトを使用できます。

2. tokenId 0でNFTを鋳造します。

3. このEnglishAuctionコントラクトをデプロイします。NFTコントラクトのアドレスを`_nft`パラメータとして、`_nftId`には0を、`_startingBid`には1を引数として使用します。

4. NFTコントラクトの`approve`関数を呼び出し、オークションコントラクトのアドレスを`to`パラメータとして、`tokenId`には0を引数として指定します。これにより、コントラクトがオークションに出品されるトークンを転送できるようになります。

5. オークションコントラクトの`start`関数を呼び出します。今`started`関数を呼び出すと、`true`を返すはずです。`highestBid`関数を呼び出すと1を返すはずです。

6. トランザクションに付随する値を3 Weiに設定し、オークションコントラクトの`bid`関数を呼び出します。`highestBid`関数を呼び出すと、3を返すはずです。
