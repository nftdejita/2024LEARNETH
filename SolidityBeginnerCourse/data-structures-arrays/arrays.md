次のセクションでは、Solidityでデータを整理し保存するために使用できるデータ構造について見ていきます。

*配列*、*マッピング*、および*構造体*はすべて*参照型*です。*値型*（例：*ブール値*や*整数*）とは異なり、参照型はその値を直接格納しません。代わりに、値が格納されている場所を格納します。複数の参照型変数が同じ場所を参照することがあり、1つの変数での変更が他の変数に影響を与えるため、慎重に扱う必要があります。

Solidityでは、配列は同じ型の値の順序付きリストを数値インデックスで格納します。

配列には、コンパイル時の*固定サイズ*配列と*動的配列*の2種類があります。固定サイズ配列では、コンパイル前に配列のサイズを宣言する必要があります。動的配列のサイズは、コントラクトがコンパイルされた後に変更できます。

### 配列の宣言
固定サイズ配列は、その型、配列サイズ（角括弧内の整数として）、可視性、および名前を提供して宣言します（9行目）。

動的配列も同じ方法で宣言しますが、配列サイズを提供せず、角括弧を空のままにします（6行目）。

### 配列の初期化
配列の要素は一度に初期化することもできます（7行目）、または個別に新しい要素を初期化することもできます（arr[0] = 1;）。配列を宣言すると、自動的に要素がデフォルト値0で初期化されます（9行目）。

### 配列要素へのアクセス
配列内の要素にアクセスするには、配列の名前と角括弧内のインデックスを提供します（12行目）。

### 配列要素の追加
`push()`メンバ関数を使用して、動的配列の末尾に要素を追加します（25行目）。

### 配列要素の削除
`pop()`メンバ関数を使用して、動的配列の最後の要素を削除します（31行目）。

`delete`演算子を使用して、配列から特定のインデックスの要素を削除できます（42行目）。
`delete`演算子で要素を削除すると、他のすべての要素は同じままなので、配列の長さは変わりません。これにより、配列にギャップが生じます。
配列の順序が重要でない場合は、配列の最後の要素を削除された要素の場所に移動することができます（46行目）、またはマッピングを使用することができます。データ構造内で要素を削除する予定がある場合、マッピングを使用する方が良いかもしれません。

### 配列の長さ
lengthメンバを使用して、配列に格納されている要素の数を読み取ることができます（35行目）。

<a href="https://www.youtube.com/watch?v=vTxxCbwMPwo" target="_blank">配列のビデオチュートリアルを見る</a>。

## ⭐️ 課題
1. `arr3`という名前の公開固定サイズ配列を0, 1, 2の値で初期化します。サイズはできるだけ小さくしてください。
2. `getArr()`関数を変更して`arr3`の値を返すようにします。