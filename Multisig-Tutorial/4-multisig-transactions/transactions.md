このセクションでは、トランザクションの提出と確認のプロセスを探ります。

## 修飾子
このコントラクトのバージョンには新しい修飾子があります。それらを一つずつ見ていきましょう。

1. **`txExists`修飾子：**（13行目）トランザクションが存在することを確認します。これは、トランザクションのインデックスが`transactions`配列の長さより小さいことを確認することで行います。この修飾子については、後で詳しく説明します。
2. **`notExecuted`修飾子：**（18行目）トランザクションが実行されていないことを確認します。これは、トランザクションの`executed`変数がfalseであることを確認することで行います。
3. **`notConfirmed`修飾子：**（23行目）トランザクションが呼び出し元によって確認されていないことを確認します。これは、トランザクションインデックスと呼び出し元のアドレスの`isConfirmed`マッピングがfalseであることを確認することで行います。

## トランザクション構造体
28行目に`Transaction`という構造体があります。この構造体メンバーには、`to`、`value`、`data`、`executed`、および`numConfirmations`が含まれます。

## 確認のマッピング
37行目に`isConfirmed`というマッピングがあります。このマッピングは、各トランザクションの確認を追跡するために使用されます。トランザクションのインデックスを所有者のアドレスにマッピングし、boolean値を持ちます。このboolean値は、特定の所有者がトランザクションを確認したかどうかを示します。

## トランザクション配列
39行目に`transactions`という配列があります。この配列は、マルチシグウォレットに提出されたすべてのトランザクションを格納します。

## イベント
このバージョンのコントラクトには4つの新しいイベントがあります：
1. **`SubmitTransaction`イベント：** トランザクションがマルチシグウォレットに提出されるたびに発生します。
2. **`ConfirmTransaction`イベント：** 所有者がトランザクションを確認するたびに発生します。
3. **`RevokeConfirmation`イベント：** 所有者がトランザクションの確認を取り消すたびに発生します。
4. **`ExecuteTransaction`イベント：** トランザクションが実行されるたびに発生します。

## submitTransaction関数
`submitTransaction`関数（78行目）は、ユーザーがマルチシグウォレットにトランザクションを提出できるようにします。この関数は、`to`、`value`、および`data`の3つのパラメータを取ります。`to`パラメータはトランザクションの受信者のアドレスです。`value`パラメータは送信されるEtherの量です。`data`パラメータは受信者に送信されるデータです。所有者のみがトランザクションを提出できます。

85行目で、新しいトランザクション構造体を作成し、`transactions`配列にプッシュし、`SubmitTransaction`イベントを発生させます。`txIndex`変数はトランザクションインデックスを追跡するために使用されます。

## confirmTransaction関数
`confirmTransaction`関数（98行目）は、ユーザーがトランザクションを確認できるようにします。この関数は1つのパラメータ、`txIndex`を取ります。
この関数には、`onlyOwner`、`txExists`、および`notExecuted`の3つの修飾子があります。`onlyOwner`修飾子は、所有者のみがトランザクションを確認できることを保証します。`txExists`修飾子は、トランザクションが存在することを保証します。`notExecuted`修飾子は、トランザクションが実行されていないことを保証します。

101行目で、トランザクションを`transaction`というローカル変数に格納します。次に、トランザクションの`numConfirmations`変数をインクリメントし、トランザクションインデックスと呼び出し元のアドレスの`isConfirmed`マッピングをtrueに設定します。最後に、`ConfirmTransaction`イベントを発生させます。

## executeTransaction関数
`executeTransaction`関数（108行目）は、ユーザーがトランザクションを実行できるようにします。113行目で、トランザクションの確認数が必要な確認数以上であることを要求します。次に、トランザクションの`executed`変数をtrueに設定します。最後に、`call`関数を使用して資金を送信します。これは、トランザクションの値とデータを使用して受信者アドレスに`call`を行うものです。トランザクションが成功した場合、`ExecuteTransaction`イベントを発生させます。

## getTransactionCount関数
`getTransactionCount`関数（132行目）は、ユーザーがマルチシグウォレット内のトランザクション数を取得できるようにします。これは、`transactions`配列の長さを返します。

## getTransaction関数
`getTransaction`関数（136行目）は、ユーザーがトランザクションを取得できるようにします。これは、前述のトランザクション構造体メンバーを返します。

## 結論
このセクションでは、トランザクションの提出、確認、および実行のプロセスを探りました。`submitTransaction`、`confirmTransaction`、および`executeTransaction`関数を調査し、複数のユーザーがトランザクションを提出および確認する方法を理解しました。

## ⭐️ 課題：トランザクションの実行
最初のアカウントに2 Etherを送信するトランザクションを提出、確認、および実行してください。

1. 前回の課題と同様にマルチシグコントラクトをデプロイします。必要な確認数が2であることを確認してください。
2. 前回の課題と同様に4 Etherを送信してマルチシグに資金を提供します。
3. 最初のアカウントに2 Etherを送信するトランザクションを送信します（`submitTransaction`を使用）。このトランザクションを提出したら、`getTransactionCount`をクリックすると、1つのトランザクションが表示されるはずです。または、`getTransaction`をクリックして、トランザクションインデックスとして0を挿入すると、提出したトランザクションが表示されます。
4. 次に、`confirmTransaction`をクリックして、トランザクションインデックスとして0を挿入します。再度`getTransaction`をクリックすると、トランザクションが1回確認されたことが表示されます。
5. 2番目の所有者アカウントに切り替えて、再度トランザクションを確認します。再度`getTransaction`をクリックすると、トランザクションが2回確認されたことが表示されます。
6. 最後のステップはトランザクションの実行です。`executeTransaction`をクリックして、トランザクションインデックスとして0を挿入します。再度`getTransaction`をクリックすると、トランザクションが実行されたことが表示されます。また、最初のアカウントの残高を確認すると、2 Ether増加しており、マルチシグウォレットの残高が2 Ether減少しているはずです。

**ヒント：**
トランザクションを提出する場合、値がWeiであり、`_data`フィールドが正しく入力されていることを確認してください。例えば、次のようになります："0x5B38Da6a701c568545dCfcB03FcB875f56beddC4, 2000000000000000000, 0x"（2 Etherの場合）。
