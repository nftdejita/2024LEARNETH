このセクションでは、マルチシグスマートコントラクトの**初期化プロセス**を探ります。コンストラクタ関数を調査し、コントラクトの初期状態がどのように設定されるかを確認します。

## 注意
このセクションから、このチュートリアルではマルチシグコントラクトを構築していきます。次のセクションでは、コントラクトがますます完全なものになっていきます。

## 概要
このセクションでは、コントラクトはイベント、状態変数、修飾子、および関数で構成されています。**イベント**は、ブロックチェーン上で指定された活動をログに記録することで透明性を提供し、**修飾子**は特定の関数を実行できるユーザーを認証する役割を果たします。

## 状態変数
4行目にMultisigWalletコントラクトがあります。コントラクトの冒頭には、3つの状態変数があります。

1. **`owners`：** マルチシグウォレットのすべての所有者のアドレスを含む配列（5行目）。
2. **`isOwner`：** アドレスが所有者かどうかを示すマッピング（6行目）。
3. **`numConfirmationsRequired`：** トランザクションに必要な確認の数（7行目）。

配列とマッピングのセットアップにより、所有者のリストを簡単に取得し、アドレスが所有者かどうかを確認することができます。

## 修飾子
次に、`onlyOwner`という修飾子があります（9行目）。Solidityの修飾子は、関数の動作を変更するために使用される特別なキーワードです。今回のケースでは、`onlyOwner`修飾子は、所有者のみが関数を実行できることを保証します。これは、**呼び出し元**のアドレスが所有者であるかどうかを確認することで実行されます。

## コンストラクタ関数
`constructor`関数（14行目）は、コントラクトのデプロイ時に一度だけ実行されます。この関数は、所有者のリストと必要な確認の数などの重要なパラメータを初期化します（14行目）。

15行目と16行目には、入力が有効であることを確認するための`require`文があります。この場合、少なくとも1人の所有者が必要であり、必要な確認数は0より大きく、所有者の数以下である必要があります。

コンストラクタは次に、アドレスが`address(0)`ではないこと（25行目）と、所有者が一意であることを確認します（26行目）。次に、`isOwner`マッピングにキー/値ペアを追加し（28行目）、提供された所有者のアドレスで`owners`配列を埋めます（29行目）。

最後に、`numConfirmationsRequired`変数に指定された値を設定します（32行目）。

## getOwners関数
`getOwners`関数（36行目）は、ユーザーがマルチシグウォレットの所有者リストを取得できるようにします。これは`owners`配列を返します（37行目）。

## getNumConfirmationsRequired関数
`getNumConfirmationsRequired`関数（41行目）は、トランザクションに必要な確認数をユーザーが取得できるようにします。これは`numConfirmationsRequired`変数を返します（42行目）。

## 結論
このセクションでは、マルチシグスマートコントラクトの初期化プロセスを探りました。コンストラクタ関数を調査し、コントラクトの初期状態がどのように設定されるかを理解しました。

## ⭐️ 課題：マルチシグウォレットのデプロイ
3人の所有者がいて、トランザクションの実行には2つの確認が必要なマルチシグコントラクトをデプロイしてください。

1. contractInitialization.solをコンパイルします。
2. RemixのDeploy & Run Transactionsに移動します。
3. 「Deploy」セクションを展開します。
4. "_OWNERS"の下に3つのアドレスの配列を入力します。
5. "_NUM_CONFIRMATIONS_REQUIRED"の下に、トランザクションに必要な確認数を入力します。

**ヒント：**
- アドレスは「ACCOUNTS」ドロップダウンメニューから取得できます。
- アドレスの配列は、["0x123...", "0x456...", "0x789..."]の形式で入力してください。
